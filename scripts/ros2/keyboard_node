#!/usr/bin/env python3

import os
os.environ["SDL_AUDIODRIVER"] = "dummy"

import pygame
import rclpy
from rclpy.node import Node
import numpy as np
from geometry_msgs.msg import Twist
from std_srvs.srv import Trigger
from std_msgs.msg import Bool

from ament_index_python.packages import get_package_share_directory

pkg_share = get_package_share_directory('wolf_controller')
path_full_keyboard_buttons = os.path.join(pkg_share, "resources/keyboard_controls.png")
path_simple_keyboard_buttons = os.path.join(pkg_share, "resources/simple_keyboard_controls.png")
path_icon = os.path.join(pkg_share, "resources/wolf_logo.png")

moveBindings = {
    "w": np.array([1,0,0,0,0,0]), "s": np.array([-1,0,0,0,0,0]),
    "a": np.array([0,0,0,0,0,1]), "d": np.array([0,0,0,0,0,-1]),
    "q": np.array([0,1,0,0,0,0]), "e": np.array([0,-1,0,0,0,0]),
    "o": np.array([0,0,1,0,0,0]), "l": np.array([0,0,-1,0,0,0]),
    "u": np.array([0,0,0,0,1,0]), "j": np.array([0,0,0,0,-1,0]),
    "h": np.array([0,0,0,1,0,0]), "k": np.array([0,0,0,-1,0,0])
}

class TriggerService:
    def __init__(self, node, service_name, timeout=5.0):
        self.called = False
        self.node = node
        self.service_name = service_name
        self._srv = node.create_client(Trigger, service_name)
        if not self._srv.wait_for_service(timeout_sec=timeout):
            node.get_logger().warn(f"{service_name} not available after {timeout}s")
            self.valid = False
        else:
            node.get_logger().info(f"{service_name} ready")
            self.valid = True
    def __call__(self):
        if self.valid and self._srv.service_is_ready():
            self._srv.call_async(Trigger.Request())
            self.called = True
    def reset(self):
        self.called = False

class TriggerButton:
    def __init__(self, data=None):
        self.called = False
        self.data = data
    def __call__(self, new_data):
        self.called = True
        self.data = new_data
    def reset(self):
        self.called = False

class KeyboardController(Node):
    def __init__(self):
        super().__init__('keyboard_controller_node')
        pygame.init()
        self.simple_view = TriggerButton(True)

        # Declare core parameters
        self.declare_parameter('robot_name', '')
        self.declare_parameter('max_linear_x', 1.0)
        self.declare_parameter('max_linear_y', 1.0)
        self.declare_parameter('max_linear_z', 1.0)
        self.declare_parameter('max_angular_x', 1.0)
        self.declare_parameter('max_angular_y', 1.0)
        self.declare_parameter('max_angular_z', 1.0)
        self.declare_parameter('stop_without_input', False)
        self.declare_parameter('twist_topic', 'wolf_controller/keyboard')

        # Declare optional service/topic parameters
        service_keys = [
            'reset_base_service', 'switch_posture_service', 'emergency_stop_service',
            'switch_gait_service', 'push_recovery_service', 'increase_step_service',
            'decrease_step_service', 'switch_control_mode_service'
        ]
        for key in service_keys:
            self.declare_parameter(key, '')

        self.declare_parameter('emergency_stop_topic', '')

        # Read core parameters
        self.robot_name = self.get_parameter('robot_name').get_parameter_value().string_value
        self.stop_without_input = self.get_parameter('stop_without_input').get_parameter_value().bool_value
        twist_topic = self.get_parameter('twist_topic').get_parameter_value().string_value

        self.max_linear = np.array([
            self.get_parameter('max_linear_x').get_parameter_value().double_value,
            self.get_parameter('max_linear_y').get_parameter_value().double_value,
            self.get_parameter('max_linear_z').get_parameter_value().double_value
        ])
        self.max_angular = np.array([
            self.get_parameter('max_angular_x').get_parameter_value().double_value,
            self.get_parameter('max_angular_y').get_parameter_value().double_value,
            self.get_parameter('max_angular_z').get_parameter_value().double_value
        ])

        # GUI setup
        title = self.robot_name or 'keyboard'
        pygame.display.set_caption(f'{title} controls')
        self.display_surface = pygame.display.set_mode((710, 440))
        self.image = pygame.image.load(path_simple_keyboard_buttons)
        pygame.display.set_icon(pygame.image.load(path_icon))

        self.twist_pub = self.create_publisher(Twist, twist_topic, 1)
        self.get_logger().info(f"Publishing Twist messages to: {twist_topic}")

        # Trigger services (dynamically created)
        self.trigger_services = {}
        for key in service_keys:
            name = self.get_parameter(key).get_parameter_value().string_value
            if name:
                self.trigger_services[key] = TriggerService(self, name)

        # Emergency stop logic
        estop_topic = self.get_parameter('emergency_stop_topic').get_parameter_value().string_value
        estop_service = self.get_parameter('emergency_stop_service').get_parameter_value().string_value
        self.estop_active = False  # Toggle state

        if estop_topic:
            self.emergency_stop_type = 'topic'
            self.emergency_stop_pub = self.create_publisher(Bool, estop_topic, 1)
            self.emergency_stop = TriggerButton()
            self.get_logger().info(f"Emergency stop set as topic: {estop_topic}")
        elif estop_service:
            self.emergency_stop_type = 'service'
            self.emergency_stop = TriggerService(self, estop_service)
            self.get_logger().info(f"Emergency stop set as service: {estop_service}")
        else:
            self.emergency_stop_type = None
            self.emergency_stop = None
            self.get_logger().warn("No emergency stop configured.")

        self.timer = self.create_timer(0.01, self.main_loop)

    def main_loop(self):
        self.display_surface.fill((255,255,255))
        self.display_surface.blit(self.image, (-125,-50))

        keys = pygame.key.get_pressed()
        cmd = np.zeros(6)
        key_pressed = False

        if keys[ord('1')] and not self.simple_view.called:
            self.simple_view(not self.simple_view.data)
            self.image = pygame.image.load(path_simple_keyboard_buttons if self.simple_view.data else path_full_keyboard_buttons)

        # Continuous movement keys
        for k, v in moveBindings.items():
            if keys[ord(k)]:
                cmd += v
                key_pressed = True

        # One-time events from keypresses (ESC, service triggers, etc.)
        for event in pygame.event.get():
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE and self.emergency_stop:
                    if self.emergency_stop_type == 'topic':
                        self.estop_active = not self.estop_active
                        msg = Bool()
                        msg.data = self.estop_active
                        self.emergency_stop_pub.publish(msg)
                        state_str = "activated" if msg.data else "cleared"
                        self.get_logger().info(f"Emergency stop {state_str}")
                    elif self.emergency_stop_type == 'service' and not self.emergency_stop.called:
                        self.emergency_stop()

                # Handle service key triggers
                keymap = {
                    pygame.K_r: 'reset_base_service',
                    pygame.K_g: 'switch_gait_service',
                    pygame.K_RETURN: 'switch_posture_service',
                    pygame.K_TAB: 'push_recovery_service',
                    pygame.K_RSHIFT: 'increase_step_service',
                    pygame.K_LSHIFT: 'decrease_step_service',
                    pygame.K_SPACE: 'switch_control_mode_service'
                }
                if event.key in keymap:
                    svc_key = keymap[event.key]
                    if svc_key in self.trigger_services and not self.trigger_services[svc_key].called:
                        self.trigger_services[svc_key]()

            elif event.type == pygame.KEYUP:
                self.simple_view.reset()
                for svc in self.trigger_services.values():
                    svc.reset()
                if event.key == pygame.K_ESCAPE and self.emergency_stop_type == 'topic':
                    self.emergency_stop.reset()

        if self.stop_without_input and not key_pressed:
            return

        cmd[:3] = np.clip(cmd[:3], -1, 1) * self.max_linear
        cmd[3:] = np.clip(cmd[3:], -1, 1) * self.max_angular

        twist = Twist()
        twist.linear.x, twist.linear.y, twist.linear.z = cmd[:3]
        twist.angular.x, twist.angular.y, twist.angular.z = cmd[3:]
        self.twist_pub.publish(twist)

        pygame.display.update()


def main(args=None):
    rclpy.init(args=args)
    node = KeyboardController()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
